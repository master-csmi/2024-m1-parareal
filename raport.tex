\documentclass{article}
\usepackage{graphicx}
\usepackage{lipsum}

\title{Parareal Algorithm}
\author{Oussama  BOUHENNICHE, 
Narimane ZAOUACHE}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
    Solving time-de­pendent partial differe­ntial equations (PDEs) numerically is 
    a significant task in computational domains. Traditional methods can be­ 
    time-consuming, especially for long simulations or comple­x systems. 
    The Parareal algorithm \cite{lions2001resolution} offe­rs an efficient parallel solution to acce­lerate PDE solving.

    In this project, we aim to implement the Parareal algorithm in feel++ framework in parallel and in C++. 
    By integrating the Parareal algorithm with Feel++, 
    we can leverage the advanced numerical methods and parallel computing 
     capabilities of both frameworks to tackle challenging time-dependent PDE problems.
    \end{abstract}

\section{Introduction}

 
 \section{Methodology}
 \subsection{Implementing the Lorenz model}


 The Lorenz system\cite{lorenz1963deterministic}, introduced by meteorologist Edward Lorenz in 1963, 
 is a set of nonlinear ordinary differential equations describing the behavior of a dynamic system. 
 This system is used as a mathematical model to study phenomena such as convection and turbulence, 
 as well as in other areas such as population dynamics, chaos theory, and control theory.



 The Lorenz system is described by the following three equations:

 \[
\left\{
\begin{array}{ccc}
\frac{dx}{dt} = \sigma(y - x) \\
\frac{dy}{dt} = x(\rho - z) - y \\
\frac{dz}{dt} = xy - \beta z
\end{array}
\right.
\]

Where $x$, $y$, and $z$ represent the state variables of the system, 
$t$ is time, and $\sigma$, $\rho$, and $\beta$ are positive real parameters.

Edward Lorenz discovered that, for the parameter values 
$\sigma = 10$, $b = 8/3$, and $\rho = 28$, a large set of solutions are attracted to a butterfly shaped set (called the Lorenz attractor). 
The trajectory seems to randomly jump betwen the two wings of the butterfly. 
The behavior exhibited by the system is called "chaos", while this type of attractor is called a "strange attractor". 

The numerical solution of the Lorenz system involves using numerical methods to approximate the trajectory of the state variables over time. 
Two commonly used methods are the fourth-order Runge-Kutta (RK4) method and the Euler method.

\subsubsection{First-order method: Euler Method}
The Euler method is an iterative method that involves approximating the temporal derivatives 
of the state variables using finite differences and using these approximations to update the values of the state variables at each time step. 

\subsubsection{Fourth-order method: Runge-Kutta (RK4) Method}
The fourth-order Runge-Kutta (RK4) method is an iterative method that involves discretizing 
time and using iterations to compute the values of the state variables at each time step. 
This method uses four successive approximations to improve the accuracy of the solution. 

\section{odeint and solve\_ivp}
SciPy is an open-source Python library specialized in scientific and technical computing. It offers a wide range of functionalities for solving mathematical, scientific, and engineering problems, thanks to its numerous specialized sub-modules. Among these sub-modules, \texttt{scipy.integrate} is dedicated to numerical integration, allowing for the solution of ordinary differential equations.
\subsection{scipy.integrate}
This sub-library offers functions such as \texttt{odeint} and \texttt{solve\_ivp} for solving ODEs, as well as other methods for single and multiple function integratio
\subsubsection{odeint from scipy.integrate}
The \texttt{odeint} function from \texttt{scipy.integrate} is widely used for numerically solving systems of ordinary differential equations (ODEs) with initial conditions \cite{scipy_ode}. It uses the LSODA (Livermore Solver for Ordinary Differential Equations) algorithm to perform integration, thus providing a fast and efficient solution. Although simple to use, \texttt{odeint} is limited in terms of control over integration methods and does not allow for the specification of events or constraints.
\subsubsection{solve\_ivp from scipy.integrate}
The \texttt{solve\_ivp} function from \texttt{scipy.integrate} offers a more unified and flexible interface for solving ODEs. It supports a variety of integration methods, including RK45 and RK23, and also allows for the specification of events and constraints for flexible termination conditions. \texttt{solve\_ivp} is thus more versatile than \texttt{odeint}, providing increased control over the integration process and suitable for a wider variety of ODE problems.
\subsection{Conclusion}
Overall, \texttt{scipy.integrate} from SciPy offers powerful tools for solving a variety of numerical integration problems, especially ODEs. While \texttt{odeint} is simple to use and fast for common cases, \texttt{solve\_ivp} offers finer flexibility and control, making it suitable for a broader range of problems. The choice between these two functionalities will depend on the specific requirements of the problem at hand. By combining the power of SciPy with the functionality of \texttt{scipy.integrate}, users can effectively address a wide range of mathematical and scientific challenges in Python.

\section{Results and Discussion}


\section{Conclusion}

\bibliographystyle{plain}
\bibliography{./References}
\end{document}