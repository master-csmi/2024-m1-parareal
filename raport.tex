\documentclass{article}
\usepackage{graphicx}
\usepackage{lipsum}
\usepackage{url}
\usepackage{hyperref}

\title{Parareal Algorithm}
\author{Oussama  BOUHENNICHE, 
Narimane ZAOUACHE}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
    Solving time-de­pendent partial differe­ntial equations (PDEs) numerically is 
    a significant task in computational domains. Traditional methods can be­ 
    time-consuming, especially for long simulations or comple­x systems. 
    The Parareal algorithm \cite{lions2001resolution} offe­rs an efficient parallel solution to acce­lerate PDE solving.

    In this project, we aim to implement the Parareal algorithm in feel++ framework in parallel and in C++. 
    By integrating the Parareal algorithm with Feel++, 
    we can leverage the advanced numerical methods and parallel computing 
     capabilities of both frameworks to tackle challenging time-dependent PDE problems.
    \end{abstract}

\section{Introduction}

    This project, carried out by \href{http://cemosis.fr}{Cemosis} \cite{cemosis} (Centre for Modeling and Simulation in Strasbourg),
    focuses on the study and implementation of the Parareal algorithm, a parallel method for temporal discretization. 


    The primary objective of this project is to investigate the Parareal algorithm and its application in solving partial differential equations (PDEs) using the Cemosis Feel++ framework. 
    

    The project is divided into four sub-objectives. 
    The first one is to implement the Parareal algorithm sequentially in Python for the Lorenz model, 
    a set of nonlinear ordinary differential equations. 
    The second is to implement the Parareal algorithm in parallel in Python for the same Lorenz model. 
    The third is to implement the Parareal algorithm sequentially in Python for the heat equation using the Feel++ framework. 
    Finally, the fourth one is to implement the Parareal algorithm in parallel in Python for the heat equation using the Feel++ framework.


    Throughout this project, we will utilize Python as the programming language and the Feel++ framework, 
    which provides a powerful tool for solving PDEs. 
    By exploring the Parareal algorithm and its implementation in different configurations, 
    we aim to demonstrate its potential in accelerating the solution of PDEs and its applicability to large-scale simulations.
    \section{Methodology}
 
    Solving nonlinear dynamical systems is pivotal in various scientific and engineering domains. The Lorenz system, introduced by meteorologist Edward Lorenz in the 1960s to model atmospheric convections, stands as one of the most famous examples of such systems. With its chaotic properties, the Lorenz system has become an ideal testbed to assess the effectiveness of different numerical solution methods.
    
    This report focuses primarily on the Parareal algorithm, while also examining commonly used numerical methods for solving the Lorenz system, such as Euler's method, the Runge-Kutta method, and the odeint function. Although each of these methods has its own advantages and disadvantages and is applied in specific contexts depending on requirements for precision, computation time, and stability, the Parareal algorithm particularly captures our interest due to its unique ability to accelerate convergence through parallelization.
    
    \section{The Lorenz model}
   
   
    The Lorenz system\cite{lorenz1963deterministic}, introduced by meteorologist Edward Lorenz in 1963, 
    is a set of nonlinear ordinary differential equations describing the behavior of a dynamic system. 
    This system is used as a mathematical model to study phenomena such as convection and turbulence, 
    as well as in other areas such as population dynamics, chaos theory, and control theory.
   
   
   
    The Lorenz system is described by the following three equations:
   
    \[
   \left\{
   \begin{array}{ccc}
   \frac{dx}{dt} = \sigma(y - x) \\
   \frac{dy}{dt} = x(\rho - z) - y \\
   \frac{dz}{dt} = xy - \beta z
   \end{array}
   \right.
   \]
   
   Where $x$, $y$, and $z$ represent the state variables of the system, 
   $t$ is time, and $\sigma$, $\rho$, and $\beta$ are positive real parameters.
   
   Edward Lorenz discovered that, for the parameter values 
   $\sigma = 10$, $b = 8/3$, and $\rho = 28$, a large set of solutions are attracted to a butterfly shaped set (called the Lorenz attractor). 
   The trajectory seems to randomly jump betwen the two wings of the butterfly. 
   The behavior exhibited by the system is called "chaos", while this type of attractor is called a "strange attractor". 
   
   The numerical solution of the Lorenz system involves using numerical methods to approximate the trajectory of the state variables over time. 
   \section{Implementing the Lorenz model}
   
   \subsection{First-order method: Euler Method}
   The Euler method is an iterative method that involves approximating the temporal derivatives 
   of the state variables using finite differences and using these approximations to update the values of the state variables at each time step. 
   
   \subsection{Fourth-order method: Runge-Kutta (RK4) Method}
   The fourth-order Runge-Kutta (RK4) method is an iterative method that involves discretizing 
   time and using iterations to compute the values of the state variables at each time step. 
   This method uses four successive approximations to improve the accuracy of the solution. 
   
   \subsection{odeint and solve\_ivp}
   SciPy is an open-source Python library specialized in scientific and technical computing. It offers a wide range of functionalities for solving mathematical, scientific, and engineering problems, thanks to its numerous specialized sub-modules. Among these sub-modules, \texttt{scipy.integrate} is dedicated to numerical integration, allowing for the solution of ordinary differential equations.
   \subsubsection{scipy.integrate}
   This sub-library offers functions such as \texttt{odeint} and \texttt{solve\_ivp} for solving ODEs, as well as other methods for single and multiple function integration.
   
   \paragraph{odeint from scipy.integrate}
   The \texttt{odeint} function from \texttt{scipy.integrate} is widely used for numerically solving systems of ordinary differential equations (ODEs) with initial conditions \cite{scipy_ode}. It uses the LSODA (Livermore Solver for Ordinary Differential Equations) algorithm to perform integration, thus providing a fast and efficient solution. Although simple to use, \texttt{odeint} is limited in terms of control over integration methods and does not allow for the specification of events or constraints.
   \paragraph{\_ivp from scipy.integrate}
   The \texttt{solve\_ivp} function from \texttt{scipy.integrate} offers a more unified and flexible interface for solving ODEs. It supports a variety of integration methods, including RK45 and RK23, and also allows for the specification of events and constraints for flexible termination conditions. \texttt{solve\_ivp} is thus more versatile than \texttt{odeint}, providing increased control over the integration process and suitable for a wider variety of ODE problems.
   
   \subsubsection{Conclusion}
   Overall, \texttt{scipy.integrate} from SciPy offers powerful tools for solving a variety of numerical integration problems, especially ODEs. While \texttt{odeint} is simple to use and fast for common cases, \texttt{solve\_ivp} offers finer flexibility and control, making it suitable for a broader range of problems. The choice between these two functionalities will depend on the specific requirements of the problem at hand. By combining the power of SciPy with the functionality of \texttt{scipy.integrate}, users can effectively address a wide range of mathematical and scientific challenges in Python.
   
   \subsection{Parareal algorithm}
   \subsubsection{Introduction}
   
   The Parareal algorithm is a parallel-in-time integration method designed to solve large-scale time-dependent differential equations. It was introduced by Lions, Maday, and Turinici in 2001. The method aims to address the challenge of efficiently solving these equations, which is often computationally expensive, by parallelizing the time dimension, in addition to spatial parallelization typically used in numerical simulations.
   \subsubsection{Overview of the Parareal Algorithm}
   
   The Parareal algorithm decomposes the time domain into sub-intervals and uses a combination of a coarse (fast but less accurate) solver and a fine (slow but more accurate) solver to iteratively refine the solution. Here's a step-by-step outline of how the algorithm works:
   
   \paragraph{Initialization}
   The initial conditions are propagated across the entire time domain using the coarse solver. This provides a rough approximation of the solution at each time step.
   \paragraph{Iterative Refinement}
   For each iteration $k$ :
   \paragraph{Prediction} Use the coarse solver to advance the solution from the current time step to the next.
   \paragraph{Correction}  Use the fine solver to advance the solution for each sub-interval. Then, correct the prediction by comparing the coarse and fine solutions.
   
   The correction step updates the solution to reduce the error introduced by the coarse solver.
   \paragraph{Convergence}
   The process is repeated until the solution converges to a desired level of accuracy.
   \subsubsection{Detailed Steps}
   
   \paragraph{Initialization:} 
     \subparagraph{Define the Solvers:}
     
     
        \textbf{Coarse Solver $(G)$:} Provides quick but less accurate approximations.
        
        \textbf{Fine Solver ($F$):} Provides accurate solutions but is computationally expensive.
        
     \subparagraph{Decompose the Time Interval:}
      Divide the total time interval 
   $[t_0,T]$ into
   $N$ equal subintervals, each of length 
   $\Delta T$. 
   \paragraph{Zero Iteration}
   Use the coarse solver $G$ serially to obtain an initial approximation of the solution:
    $$ U_{j+1}^0 = G(t_j,t_{j+1}, U_j^0)$$   for $j = 0, ........, N-1$.
   \paragraph{Subsequent Iterations} 
       \subparagraph{Parallel Fine Solver Application:} 
           For each iteration $k$, apply the fine solver $F$ in parallel over each time subinterval, starting from the most recent solution values:
   
   $$ F(t_j,t_{j+1}, U_j^{k-1})$$ for $j = 0, ....,N-1$.
        \subparagraph{Update with Predictor-Corrector:}
        Update the solution values using a combination of the coarse and fine solvers:
        $$ U_{j+1}^k = G(t_j,t_{j+1},U_j^k) + F(t_j,t_{j+1},U_j^{k-1}) -G(t_j,t_{j+1},U_j^{k-1})$$
        for $j = 0, .... ,N-1$.
        
    \paragraph{Convergence Check}
        Verify convergence by checking the difference between successive iterations:
      $$   | U_j^k - U_j^{k-1} | < \epsilon $$
   where $ \epsilon $ is a predefined tolerance. \cite{para}

\section{Results and Discussion}


\section{Conclusion}

\bibliographystyle{plain}
\bibliography{./References}
\end{document}