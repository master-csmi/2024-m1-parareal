\documentclass{article}
\usepackage{graphicx}
\usepackage{lipsum}
\usepackage{url}
\usepackage{hyperref}

\title{Parareal Algorithm}
\author{Oussama  BOUHENNICHE, 
Narimane ZAOUACHE}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
    Solving time-de­pendent partial differe­ntial equations (PDEs) numerically is 
    a significant task in computational domains. Traditional methods can be­ 
    time-consuming, especially for long simulations or comple­x systems. 
    The Parareal algorithm \cite{lions2001resolution} offe­rs an efficient parallel solution to acce­lerate PDE solving.

    In this project, our goal is to implement the Parareal algorithm both sequentially and in parallel on a chaotic mathematical model, specifically the Lorenz system. We aim to compare its performance with other advanced numerical methods. This comparison will focus on various criteria, including the accuracy of results, computational efficiency, and the ability to handle the sensitivity to initial conditions characteristic of chaotic systems. By using the Lorenz system, we can assess the robustness and speed of the Parareal algorithm in a context where small initial variations can lead to significant divergences in predictions, thereby highlighting the strengths and limitations of each method studied.
    \end{abstract}

\section{Introduction}

    This project, carried out by \href{http://cemosis.fr}{Cemosis} \cite{cemosis} (Centre for Modeling and Simulation in Strasbourg),
    focuses on the study and implementation of the Parareal algorithm, a parallel method for temporal discretization. 


    The primary objective of this project is to investigate the Parareal algorithm and its application in solving partial differential equations (PDEs). 
    

    The project is divided into two sub-objectives. 
    The first one is to implement the Parareal algorithm sequentially in Python for the Lorenz model, 
    a set of nonlinear ordinary differential equations. 
    The second is to implement the Parareal algorithm in parallel in Python for the same Lorenz model. 

    Throughout this project, we will utilize Python as the programming language. 
    By exploring the Parareal algorithm and its implementation in different configurations, 
    we aim to demonstrate its potential in accelerating the solution of PDEs and its applicability to large-scale simulations.
    \section{Methodology}
 
    Solving nonlinear dynamical systems is pivotal in various scientific and engineering domains. The Lorenz system, introduced by meteorologist Edward Lorenz in the 1960s to model atmospheric convections, stands as one of the most famous examples of such systems. With its chaotic properties, the Lorenz system has become an ideal testbed to assess the effectiveness of different numerical solution methods.
    
    This report focuses primarily on the Parareal algorithm, while also examining commonly used numerical methods for solving the Lorenz system, such as Euler's method, the Runge-Kutta method, and the odeint function. Although each of these methods has its own advantages and disadvantages and is applied in specific contexts depending on requirements for precision, computation time, and stability, the Parareal algorithm particularly captures our interest due to its unique ability to accelerate convergence through parallelization.
    
    \section{The Lorenz model}
   
   
    The Lorenz system\cite{lorenz1963deterministic}, introduced by meteorologist Edward Lorenz in 1963, 
    is a set of nonlinear ordinary differential equations describing the behavior of a dynamic system. 
    This system is used as a mathematical model to study phenomena such as convection and turbulence, 
    as well as in other areas such as population dynamics, chaos theory, and control theory.
   
   
   
    The Lorenz system is described by the following three equations:
   
    \[
   \left\{
   \begin{array}{ccc}
   \frac{dx}{dt} = \sigma(y - x) \\
   \frac{dy}{dt} = x(\rho - z) - y \\
   \frac{dz}{dt} = xy - \beta z
   \end{array}
   \right.
   \]
   
   Where $x$, $y$, and $z$ represent the state variables of the system, 
   $t$ is time, and $\sigma$, $\rho$, and $\beta$ are positive real parameters.
   
   Edward Lorenz discovered that, for the parameter values 
   $\sigma = 10$, $b = 8/3$, and $\rho = 28$, a large set of solutions are attracted to a butterfly shaped set (called the Lorenz attractor). 
   The trajectory seems to randomly jump betwen the two wings of the butterfly. 
   The behavior exhibited by the system is called "chaos", while this type of attractor is called a "strange attractor". 
   
   The numerical solution of the Lorenz system involves using numerical methods to approximate the trajectory of the state variables over time. 
   \section{Implementing the Lorenz model}
   
   \subsection{First-order method: Euler Method}
   The Euler method is an iterative method that involves approximating the temporal derivatives 
   of the state variables using finite differences and using these approximations to update the values of the state variables at each time step. 
   
   \subsection{Fourth-order method: Runge-Kutta (RK4) Method}
   The fourth-order Runge-Kutta (RK4) method is an iterative method that involves discretizing 
   time and using iterations to compute the values of the state variables at each time step. 
   This method uses four successive approximations to improve the accuracy of the solution. 
   
   \subsection{odeint and solve\_ivp}
   SciPy is an open-source Python library specialized in scientific and technical computing. It offers a wide range of functionalities for solving mathematical, scientific, and engineering problems, thanks to its numerous specialized sub-modules. Among these sub-modules, \texttt{scipy.integrate} is dedicated to numerical integration, allowing for the solution of ordinary differential equations.
   \subsubsection{scipy.integrate}
   This sub-library offers functions such as \texttt{odeint} and \texttt{solve\_ivp} for solving ODEs, as well as other methods for single and multiple function integration.
   
   \paragraph{odeint from scipy.integrate}
   The \texttt{odeint} function from \texttt{scipy.integrate} is widely used for numerically solving systems of ordinary differential equations (ODEs) with initial conditions \cite{scipy_ode}. It uses the LSODA (Livermore Solver for Ordinary Differential Equations) algorithm to perform integration, thus providing a fast and efficient solution. Although simple to use, \texttt{odeint} is limited in terms of control over integration methods and does not allow for the specification of events or constraints.
   \paragraph{\_ivp from scipy.integrate}
   The \texttt{solve\_ivp} function from \texttt{scipy.integrate} offers a more unified and flexible interface for solving ODEs. It supports a variety of integration methods, including RK45 and RK23, and also allows for the specification of events and constraints for flexible termination conditions. \texttt{solve\_ivp} is thus more versatile than \texttt{odeint}, providing increased control over the integration process and suitable for a wider variety of ODE problems.
   
   \subsubsection{Conclusion}
   Overall, \texttt{scipy.integrate} from SciPy offers powerful tools for solving a variety of numerical integration problems, especially ODEs. While \texttt{odeint} is simple to use and fast for common cases, \texttt{solve\_ivp} offers finer flexibility and control, making it suitable for a broader range of problems. The choice between these two functionalities will depend on the specific requirements of the problem at hand. By combining the power of SciPy with the functionality of \texttt{scipy.integrate}, users can effectively address a wide range of mathematical and scientific challenges in Python.
   
   \subsection{Parareal algorithm}
   \subsubsection{Introduction}
   
   The Parareal algorithm is a parallel-in-time integration method designed to solve large-scale time-dependent differential equations. It was introduced by Lions, Maday, and Turinici in 2001. The method aims to address the challenge of efficiently solving these equations, which is often computationally expensive, by parallelizing the time dimension, in addition to spatial parallelization typically used in numerical simulations.
   \subsubsection{Overview of the Parareal Algorithm}
   
   The Parareal algorithm decomposes the time domain into sub-intervals and uses a combination of a coarse (fast but less accurate) solver and a fine (slow but more accurate) solver to iteratively refine the solution. Here's a step-by-step outline of how the algorithm works:
   
   \paragraph{Initialization}
   The initial conditions are propagated across the entire time domain using the coarse solver. This provides a rough approximation of the solution at each time step.
   \paragraph{Iterative Refinement}
   For each iteration $k$ :
   \paragraph{Prediction} Use the coarse solver to advance the solution from the current time step to the next.
   \paragraph{Correction}  Use the fine solver to advance the solution for each sub-interval. Then, correct the prediction by comparing the coarse and fine solutions.
   
   The correction step updates the solution to reduce the error introduced by the coarse solver.
   \paragraph{Convergence}
   The process is repeated until the solution converges to a desired level of accuracy.
   \subsubsection{Detailed Steps}
   
   \paragraph{Initialization:} 
     \subparagraph{Define the Solvers:}
     
     
        \textbf{Coarse Solver $(G)$:} Provides quick but less accurate approximations.
        
        \textbf{Fine Solver ($F$):} Provides accurate solutions but is computationally expensive.
        
     \subparagraph{Decompose the Time Interval:}
      Divide the total time interval 
   $[t_0,T]$ into
   $N$ equal subintervals, each of length 
   $\Delta T$. 
   \paragraph{Zero Iteration}
   Use the coarse solver $G$ serially to obtain an initial approximation of the solution:
    $$ U_{j+1}^0 = G(t_j,t_{j+1}, U_j^0)$$   for $j = 0, ........, N-1$.
   \paragraph{Subsequent Iterations} 
       \subparagraph{Parallel Fine Solver Application:} 
           For each iteration $k$, apply the fine solver $F$ in parallel over each time subinterval, starting from the most recent solution values:
   
   $$ F(t_j,t_{j+1}, U_j^{k-1})$$ for $j = 0, ....,N-1$.
        \subparagraph{Update with Predictor-Corrector:}
        Update the solution values using a combination of the coarse and fine solvers:
        $$ U_{j+1}^k = G(t_j,t_{j+1},U_j^k) + F(t_j,t_{j+1},U_j^{k-1}) -G(t_j,t_{j+1},U_j^{k-1})$$
        for $j = 0, .... ,N-1$.
        
    \paragraph{Convergence Check}
        Verify convergence by checking the difference between successive iterations:
      $$   | U_j^k - U_j^{k-1} | < \epsilon $$
   where $ \epsilon $ is a predefined tolerance. \cite{pararealwikipedia}

\section{Results and Discussion}
\subsection{Euler Method (Implicit and Explicit)}
\subsection{Advantages}
 \paragraph{Implicit Euler}: Increased stability for larger time steps.
 
\paragraph{Explicit Euler}: Ease of implementation and faster computation.

\subsection{Disadvantages}
\paragraph{Implicit Euler}: More complex computation per time step.
\paragraph{Explicit Euler}: Less stable for larger time steps.

\subsection{Runge-Kutta Method (Orders 2 and 4)}
\subsection{Advantages}
\paragraph{RK2}: Better accuracy than Euler method.

\paragraph{RK4}: Even more accurate than RK2 with the same number of function evaluations.


\subsection{Disadvantages}
\paragraph{RK2}: Less accurate than RK4.

\paragraph{RK4}:  More computationally expensive per time step.

\subsection{$odeint$ and $solve_ivp$ Functions}
\subsection{Advantages}
\paragraph{$odeint$}: User-friendly for those familiar with SciPy.

\paragraph{$solve_ivp$}: More features and controls over the solving process.

\subsection{Disadvantages}
\paragraph{$odeint$}: Less flexible and may require additional manipulation for certain problems.

\paragraph{$solve_ivp$}: May be more complex for beginner users.

\subsection{Parareal Algorithm}
\subsection{Advantages}
\paragraph{Parallel Computation}: Reduces computation time by utilizing multiple processors.

\paragraph{Increased Accuracy:}: Can achieve high accuracy with successive iterations.

\subsection{Disadvantages}
\paragraph{Implementation Complexity:}
: Requires more complex implementation compared to sequential methods.

\paragraph{Dependency on Parallel Resources} : Requires parallel computing infrastructure to fully leverage its advantages.


\paragraph*{} We compared the  methods in terms of accuracy and computation time.                                     
The Parareal algorithm was the most accurate of the methods. It was able to obtain an exact solution with a much smaller number of time steps compared to the Runge-Kutta and Euler methods, ans  was the slowest of the methods. This is because it uses two propagators, a coarse propagator and a fine propagator. The Runge-Kutta and Euler methods were faster but less accurate.

The Parareal algorithm is a powerful method for solving ODEs with high precision. However, it can be slow, especially for problems that require a large number of time steps. The Runge-Kutta and Euler methods are faster but can be less accurate. The choice of method depends on the required precision and available resources.




\section{Conclusion}
Each ODE-solving method presented in this report has its own strengths, weaknesses, and suitable application areas. Euler, Runge-Kutta, odeint, and $solve_ivp$ methods are sequential approaches suitable for many problems. However, the Parareal algorithm stands out for its ability to reduce computation time using parallel computation, making it an attractive choice for problems requiring high precision over long time intervals. The choice of method will depend on the specific requirements of precision, computation speed, and implementation complexity of the problem being solved.
\bibliographystyle{plain}
\bibliography{./References}
\end{document}